# Implementation Plan: Multi-Config Management

**Branch**: `007-multi-config` | **Date**: 2025-02-05 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/007-multi-config/spec.md`

## Summary

Add support for multiple named Prometheus server configurations with seamless switching capabilities. Users can manage configurations for different environments (production, staging, development) without overwriting existing settings. The implementation will extend the existing `prom config` command with subcommands (add, list, use, current, remove) while maintaining 100% backward compatibility through automatic migration of old single-config format to multi-config structure.

**Primary Goal**: Enable users to switch between Prometheus servers in under 3 seconds without re-entering credentials, with zero breaking changes for existing installations.

## Technical Context

**Language/Version**: TypeScript 5.x with ES2022 (NodeNext module resolution)
**Primary Dependencies**: commander (CLI framework), axios (HTTP client), Node.js fs/path APIs (file operations)
**Storage**: JSON file at `~/.prom-cli/config.json` (redesigned structure for multi-config)
**Testing**: vitest with BDD-style Given/When/Then test patterns
**Target Platform**: Node.js 18+ (cross-platform: macOS, Linux, Windows)
**Project Type**: Single project (CLI tool)
**Performance Goals**: Config operations complete in < 3 seconds, command initialization < 100ms
**Constraints**: Config file size < 1MB, support up to 100 named configurations
**Scale/Scope**: ~8-10 source files modified/added, ~15-20 new test files

## Constitution Check

_GATE: Must pass before Phase 0 research. Re-check after Phase 1 design._

### I. Code Quality ✅

- Functions will follow single responsibility (e.g., loadConfig, saveConfig, migrateOldConfig as separate functions)
- Descriptive naming for configuration entities (ConfigStore, Configuration, ActiveConfigName)
- Constants for file paths, default names, error messages
- Existing config.ts patterns will be followed and extended

### II. Testing Standards (TDD/BDD) ✅

- Tests written before implementation following TDD Red-Green-Refactor cycle
- BDD Given/When/Then patterns matching acceptance scenarios from spec
- Test coverage for all 6 user stories (add, list, use, current, remove, migration)
- Error paths tested (duplicate names, non-existent configs, invalid operations)

### III. User Experience Consistency ✅

- All config subcommands provide --help with clear usage
- Error messages actionable (e.g., "Configuration 'name' not found. Available: prod, staging, dev")
- Consistent output format (table for list, confirmation messages for operations)
- Exit codes: 0 for success, 1 for user errors, 2 for system errors

### IV. Performance Requirements ✅

- Config operations complete within 3s (spec requirement: SC-002)
- Command initialization remains under 100ms
- File I/O optimized (read once, cache in memory, write only on changes)
- No network operations for config management (pure local file operations)

### V. MVP First ✅

- Implementation prioritizes P1 user stories first (add, list, use, migration)
- P2 user stories (current, remove) can be delivered in separate iteration
- Each user story independently testable and deliverable
- Migration (US6) critical for backward compatibility - must be in MVP

### VI. No Overdesign ✅

- No configuration versioning system (YAGNI - can add later if needed)
- No encryption at rest (rely on filesystem permissions, no speculative security layer)
- No import/export functionality (not in spec, can add if users request)
- No configuration templates or presets (solve current problem only)
- Simple JSON structure without complex abstractions (ConfigStore is straightforward)

**Gate Status**: ✅ **PASSED** - All principles satisfied, no violations requiring justification

## Project Structure

### Documentation (this feature)

```text
specs/007-multi-config/
├── plan.md              # This file
├── research.md          # Technology decisions and migration strategy
├── data-model.md        # Configuration data structures
├── quickstart.md        # Implementation guide for developers
├── contracts/           # CLI command contracts
│   └── cli-commands.md  # Command syntax and behavior specs
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── commands/
│   └── config.ts        # Extended with subcommands (add, list, use, current, remove)
├── services/
│   ├── config.ts        # Core config management logic (loadConfig, saveConfig, migration)
│   └── config-store.ts  # New: Multi-config store operations
├── types/
│   └── index.ts         # Updated: Configuration types
└── index.ts             # Root CLI entry point

tests/
├── config.test.ts       # Extended: Multi-config operations tests
├── config-store.test.ts # New: ConfigStore unit tests
└── config-migration.test.ts # New: Migration logic tests
```

**Structure Decision**: Single project structure (Option 1) selected because prom-cli is a CLI tool with straightforward layering. No need for separate backend/frontend or mobile/API splits. The existing src/commands, src/services, src/types structure is sufficient and maintains consistency with current codebase organization.

## Complexity Tracking

> **No violations requiring justification** - this section intentionally left minimal per constitution principle VI (No Overdesign).

## Phase 0: Research & Technology Decisions

### Research Areas

1. **Multi-config storage format**: JSON structure for storing multiple named configurations
2. **Migration strategy**: Automatic detection and migration of old single-config format
3. **Concurrent access safety**: Handling simultaneous config file access
4. **Active configuration tracking**: Mechanism for marking and loading active config

### Decisions Made

Decisions documented in [research.md](research.md) (generated in next phase)

## Phase 1: Design Artifacts

Generated artifacts:

- [data-model.md](data-model.md) - Configuration and ConfigStore entity definitions
- [contracts/cli-commands.md](contracts/cli-commands.md) - CLI command contracts for all config subcommands
- [quickstart.md](quickstart.md) - Step-by-step implementation guide

## Implementation Strategy

### MVP Scope (Phase 2 Tasks)

**Must Have (P1)**:

1. Extend `prom config` command with subcommand routing
2. Implement `prom config add <name> <url>` with authentication options
3. Implement `prom config list` with active indicator
4. Implement `prom config use <name>` for switching
5. Implement automatic migration on first run (backward compatibility)
6. Update `loadConfig()` in services/config.ts to support multi-config

**Should Have (P2)**: 7. Implement `prom config current` for displaying active config 8. Implement `prom config remove <name>` with confirmation

**Testing Strategy**:

- Unit tests for ConfigStore operations (add, list, use, remove, migrate)
- Integration tests for command-line interface (commander integration)
- Migration tests with various old config formats
- Backward compatibility tests ensuring existing commands work unchanged

### Risk Assessment

| Risk                       | Impact | Mitigation                                          |
| -------------------------- | ------ | --------------------------------------------------- |
| Breaking existing configs  | High   | Automatic migration with backup, extensive testing  |
| Concurrent file corruption | Medium | File locking or atomic write operations             |
| Migration edge cases       | Medium | Comprehensive test coverage for various old formats |
| Performance degradation    | Low    | Benchmarking config operations, optimize file I/O   |

### Dependencies

- No new external dependencies required (uses existing commander, fs APIs)
- Existing loadConfig() and saveConfig() functions will be refactored for multi-config support
- All existing commands (query, targets, labels, series, status) will automatically use active config via loadConfig()

## Quality Gates

Before merging to main:

1. ✅ All unit tests pass (vitest)
2. ✅ All integration tests pass
3. ✅ Backward compatibility verified (old config migrates successfully)
4. ✅ Constitution principles satisfied
5. ✅ Code formatted with prettier
6. ✅ TypeScript compilation successful (pnpm build)
7. ✅ Manual testing of all config subcommands

## Next Steps

1. Execute Phase 0: Generate research.md with technology decisions
2. Execute Phase 1: Generate data-model.md, contracts/, quickstart.md
3. Update agent context (CLAUDE.md) with new technology choices
4. Run `/speckit.tasks` to generate detailed task breakdown
